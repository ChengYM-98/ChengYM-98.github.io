---
title: 排序算法
date: 2022-11-12 16:33:19
tags: 算法
categories: 前端基础
cover: /img/04.jpg
---
# 冒泡排序
 - 时间复杂度：O(N2)
 - 空间复杂度：O(1)
 - 稳定性：稳定
 - 在数据有序的时候时间复杂度可以达到O(n)。适用的情景为数据量量不大，对稳定性有要求，且数据基本有序的情况下。
```js
function bubbleSort(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] < arr[j]) {
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }
    }
}
```


# 插入排序
 - 时间复杂度：O(N2)
 - 空间复杂度：O(1)
 - 稳定性：稳定
 - 适用于数据量不大，对算法的稳定性有要求，且数据局部或者整体有序的情况
```js
// 双层循环，外循环控制未排序的元素，内循环控制已排序的元素，将未排序元素设为标杆，
// 与已排序的元素进行比较，小于则交换位置，大于则位置不动
function insertSort(arr) {
    for (let i = 0; i < arr.length; i++) {
        let item = arr[i];
        for (let j = i; j >= 0; j--) {
            if (arr[j - 1] > item) {
                arr[j] = arr[j - 1];
            } else {
                arr[j] = item;
                break;
            }
        }
    }
    return arr;
}
```


# 选择排序
 - 时间复杂度：O(N2)
 - 空间复杂度：O(1)
 - 稳定性：不稳定
 - 当数据量不大，且对稳定性没有要求的时候，适用于选择排序
```js
// 先假设第一个元素为最小的，然后通过循环找出最小元素，
// 然后同第一个元素交换，接着假设第二个元素，重复上述操作即可
function selectSort(arr) {
    for (let i = 0; i < arr.length; i++) {
        let min = i;
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[min]) {
                min = j;
            }
        }
        [arr[i], arr[min]] = [arr[min], arr[i]];
    }
    return arr;
}
```


# 快速排序
 - 时间复杂度：O(NlongN)
 - 空间复杂度：O(N)
 - 稳定性：不稳定
 - 常用于查找一组中前k大的数据
```js
// 思想：他是一种分而治之的算法，找出一个参考值，通过递归的方式将数据一次分解为包含较小元素和较大元素的不同子序列，重复这个步骤直到所有数据都是有序的
// 1.选择一个参考元素，将数组分割为两个子序列
// 2.对序列重新排序，将所有小于基准的元素放在基准值的前面，大于基准值的元素放在基准值的右侧
// 3.分别对小元素的子序列和较大元素的子序列重复步骤1，2
function quickSort(arr) {
    let len = arr.length;
    let left = [], right = [];
    let current = arr[0];
    if (len <= 1) {
        return arr;
    }
    for (let i = 1; i < len; i++) {
        if (current < arr[i]) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    return quickSort(left).concat(current, quickSort(right));
}
```


# 归并排序
 - 时间复杂度：O(NlongN)
 - 空间复杂度：O(N)
 - 稳定性：稳定
 - 常用于查找一组中前k大的数据
```js
// 把长度为n的序列分成两个长度为n/2的子序列
// 对这两个子序列分别采用归并排序
// 将排序好的子序列合并程最终的有序序列
function merge(left, right) {

}
function mergeSort() {

}
```

# 总结
1. 若n较小(如n≤50)，可采用直接插入或直接选择排序。
2. 当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。
3. 若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；
4. 若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。
5. 快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；
6. 堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。
7. 若要求排序稳定，则可选用归并排序。但前面介绍的从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子序列，然后再两两归并之。因为直接插入排序是稳定 的，所以改进后的归并排序仍是稳定的。
